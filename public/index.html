<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>BlindLog Controls</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root { color-scheme: light dark; }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f8fafc;
      color: #0f172a;
      line-height: 1.5;
    }
    main {
      max-width: 640px;
      margin: 0 auto;
      padding: 2.5rem 1.5rem;
    }
    h1 {
      font-size: 1.8rem;
      margin-bottom: 1.5rem;
    }
    section {
      background: #ffffff;
      border-radius: 16px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.1);
    }
    h2 {
      margin: 0 0 0.75rem;
      font-size: 1.2rem;
    }
    button {
      appearance: none;
      border: none;
      border-radius: 999px;
      padding: 0.6rem 1.4rem;
      background: #2563eb;
      color: #ffffff;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.1s ease;
    }
    button:disabled {
      background: #9ca3af;
      cursor: progress;
    }
    button:not(:disabled):hover {
      background: #1d4ed8;
    }
    button:not(:disabled):active {
      transform: scale(0.97);
    }
    input {
      width: 100%;
      padding: 0.6rem 0.75rem;
      border-radius: 10px;
      border: 1px solid #cbd5f5;
      background: #ffffff;
      font-size: 1rem;
      color: inherit;
    }
    input:focus {
      outline: none;
      border-color: #60a5fa;
      box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.25);
    }
    .field {
      margin-bottom: 0.9rem;
    }
    .field label {
      display: block;
      margin-bottom: 0.35rem;
      font-weight: 600;
      font-size: 0.95rem;
    }
    .status {
      min-height: 1.25rem;
      margin-top: 0.75rem;
      font-size: 0.95rem;
      font-weight: 500;
    }
    pre {
      background: #0f172a;
      color: #e2e8f0;
      border-radius: 12px;
      padding: 1rem;
      overflow-x: auto;
      font-size: 0.9rem;
    }
    @media (prefers-color-scheme: dark) {
      body { background: #0f172a; color: #e2e8f0; }
      section { background: #1f2937; box-shadow: 0 16px 40px rgba(2, 6, 23, 0.45); }
      button { background: #38bdf8; color: #0f172a; }
      button:not(:disabled):hover { background: #0ea5e9; }
      input { background: #111827; border-color: #334155; color: #e2e8f0; }
      input:focus { border-color: #38bdf8; box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.4); }
      pre { background: #020617; color: #cbd5f5; }
    }
  </style>
</head>
<body>
  <main>
    <h1>BlindLog Passkey Playground</h1>

    <section>
      <h2>ユーザー作成</h2>
      <p>匿名ユーザーを作成して認証トークンを取得します。</p>
      <button id="create-user" type="button">ユーザー作成</button>
      <p id="create-status" class="status" role="status"></p>
    </section>

    <section>
      <h2>メールアドレス認証</h2>
      <p>トークンを使って確認メールを送り、受け取ったコードで認証します。</p>
      <div class="field">
        <label for="email-input">メールアドレス</label>
        <input id="email-input" type="email" autocomplete="email" placeholder="user@example.com">
      </div>
      <button id="send-email" type="button">確認メール送信</button>
      <p id="email-start-status" class="status" role="status"></p>
      <div class="field">
        <label for="email-code">確認コード</label>
        <input id="email-code" type="text" inputmode="numeric" autocomplete="one-time-code" placeholder="6桁のコード">
      </div>
      <button id="confirm-email" type="button">コードを送信</button>
      <p id="email-confirm-status" class="status" role="status"></p>
    </section>

    <section>
      <h2>Passkey追加</h2>
      <p>既存のトークンでチャレンジを取得し、Passkey を登録します。</p>
      <button id="add-passkey" type="button">Passkey追加</button>
      <p id="passkey-status" class="status" role="status"></p>
    </section>

    <section>
      <h2>Passkeyログイン</h2>
      <p>Passkey を使って認証し、新しいトークンを取得します。</p>
      <button id="login" type="button">Passkeyでログイン</button>
      <p id="login-status" class="status" role="status"></p>
    </section>

    <section>
      <h2>メールログイン</h2>
      <p>メールアドレスにコードを送り、新しいトークンを取得します。</p>
      <div class="field">
        <label for="email-login-input">メールアドレス</label>
        <input id="email-login-input" type="email" autocomplete="email" placeholder="user@example.com">
      </div>
      <button id="start-email-login" type="button">ログインコード送信</button>
      <div class="field">
        <label for="email-login-code">確認コード</label>
        <input id="email-login-code" type="text" inputmode="numeric" autocomplete="one-time-code" placeholder="6桁のコード">
      </div>
      <button id="complete-email-login" type="button">コードでログイン</button>
      <p id="email-login-status" class="status" role="status"></p>
    </section>

    <section>
      <h2>ログアウト</h2>
      <p>保持しているセッション情報を破棄します。</p>
      <button id="logout" type="button">ログアウト</button>
      <p id="logout-status" class="status" role="status"></p>
    </section>

    <section>
      <h2>セッション情報</h2>
      <pre id="session-output">セッションがありません。</pre>
    </section>
  </main>

  <script>
    (() => {
      const supportsWebAuthn = 'PublicKeyCredential' in window;

      const elements = {
        buttons: {
          create: document.getElementById('create-user'),
          sendEmail: document.getElementById('send-email'),
          confirmEmail: document.getElementById('confirm-email'),
          addPasskey: document.getElementById('add-passkey'),
          login: document.getElementById('login'),
          startEmailLogin: document.getElementById('start-email-login'),
          completeEmailLogin: document.getElementById('complete-email-login'),
          logout: document.getElementById('logout'),
        },
        statuses: {
          create: document.getElementById('create-status'),
          emailStart: document.getElementById('email-start-status'),
          emailConfirm: document.getElementById('email-confirm-status'),
          passkey: document.getElementById('passkey-status'),
          login: document.getElementById('login-status'),
          emailLogin: document.getElementById('email-login-status'),
          logout: document.getElementById('logout-status'),
        },
        inputs: {
          email: document.getElementById('email-input'),
          code: document.getElementById('email-code'),
          emailLoginEmail: document.getElementById('email-login-input'),
          emailLoginCode: document.getElementById('email-login-code'),
        },
        sessionOutput: document.getElementById('session-output'),
      };

      const status = {
        set(key, message, { error = false } = {}) {
          const element = elements.statuses[key];
          if (!element) return;
          element.textContent = message;
          element.style.color = error ? '#dc2626' : '';
        },
        clear(...keys) {
          keys.forEach(key => this.set(key, ''));
        },
      };

      // Epoch used by Date.timeIntervalSinceReferenceDate (Jan 1, 2001 UTC).
      const APPLE_REFERENCE_DATE_MS = Date.UTC(2001, 0, 1);

      const session = {
        data: {
          userID: null,
          token: null,
          tokenExpiresAt: null,
          refreshToken: null,
          refreshTokenExpiresAt: null,
          email: null,
        },
        apply(payload) {
          const data = this.data;
          const userID = payload?.userID ?? payload?.id ?? null;
          data.userID = userID;
          data.token = payload?.token ?? null;
          data.tokenExpiresAt = formatReferenceDate(payload?.tokenExpiredDate);
          data.refreshToken = payload?.refreshToken ?? null;
          data.refreshTokenExpiresAt = formatReferenceDate(payload?.refreshTokenExpiredDate);
          this.render();
        },
        updateEmail(email) {
          this.data.email = email ? email.trim() : null;
          this.render();
        },
        reset() {
          const data = this.data;
          data.userID = null;
          data.token = null;
          data.tokenExpiresAt = null;
          data.refreshToken = null;
          data.refreshTokenExpiresAt = null;
          data.email = null;
          this.render();
        },
        render() {
          const data = this.data;
          if (!data.userID) {
            elements.sessionOutput.textContent = 'セッションがありません。';
            return;
          }
          elements.sessionOutput.textContent = JSON.stringify(data, null, 2);
        },
      };

      let emailLoginChallenge = null;

      function formatReferenceDate(value) {
        if (typeof value !== 'number' || Number.isNaN(value)) {
          return null;
        }
        return new Date(APPLE_REFERENCE_DATE_MS + value * 1000).toISOString();
      }

      function normalizeBase64(input) {
        const base = input.replace(/-/g, '+').replace(/_/g, '/').replace(/\s+/g, '');
        const mod = base.length % 4;
        if (mod === 2) return base + '==';
        if (mod === 3) return base + '=';
        if (mod === 1) return base + '===';
        return base;
      }

      function base64ToUint8Array(base64) {
        const normalized = normalizeBase64(base64);
        const binary = atob(normalized);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i += 1) {
          bytes[i] = binary.charCodeAt(i);
        }
        return bytes;
      }

      function arrayBufferToBase64Url(buffer) {
        const bytes = new Uint8Array(buffer);
        let binary = '';
        for (let i = 0; i < bytes.length; i += 1) {
          binary += String.fromCharCode(bytes[i]);
        }
        const base64 = btoa(binary);
        return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
      }

      async function readChallengeResponse(response) {
        const text = (await response.text()).trim();
        try {
          const parsed = JSON.parse(text);
          if (typeof parsed === 'string') return parsed;
          if (typeof parsed?.challenge === 'string') return parsed.challenge;
          if (typeof parsed?.value === 'string') return parsed.value;
          if (Array.isArray(parsed?.data)) {
            return arrayBufferToBase64Url(Uint8Array.from(parsed.data).buffer);
          }
        } catch {
          const unquoted = text.replace(/^"|"$/g, '');
          if (unquoted) return unquoted;
        }
        throw new Error('Unexpected challenge response format.');
      }

      function buildRegistrationOptions(challenge, userID) {
        return {
          challenge: base64ToUint8Array(challenge),
          rp: { name: document.title || 'BlindLog', id: window.location.hostname },
          user: {
            id: new TextEncoder().encode(userID),
            name: userID,
            displayName: userID,
          },
          pubKeyCredParams: [
            { type: 'public-key', alg: -7 },
            { type: 'public-key', alg: -257 },
          ],
          authenticatorSelection: { userVerification: 'preferred' },
          timeout: 60000,
          attestation: 'none',
        };
      }

      function buildAuthenticationOptions(challenge) {
        return {
          challenge: base64ToUint8Array(challenge),
          rpId: window.location.hostname,
          timeout: 60000,
          userVerification: 'preferred',
        };
      }

      function serializeRegistrationCredential(credential) {
        const response = credential.response;
        return {
          id: credential.id,
          rawId: arrayBufferToBase64Url(credential.rawId),
          type: credential.type,
          response: {
            clientDataJSON: arrayBufferToBase64Url(response.clientDataJSON),
            attestationObject: arrayBufferToBase64Url(response.attestationObject),
          },
        };
      }

      function serializeAuthenticationCredential(credential) {
        const response = credential.response;
        const payload = {
          id: credential.id,
          rawId: arrayBufferToBase64Url(credential.rawId),
          type: credential.type,
          response: {
            clientDataJSON: arrayBufferToBase64Url(response.clientDataJSON),
            authenticatorData: arrayBufferToBase64Url(response.authenticatorData),
            signature: arrayBufferToBase64Url(response.signature),
          },
        };
        if (response.userHandle) {
          payload.response.userHandle = arrayBufferToBase64Url(response.userHandle);
        }
        if (credential.authenticatorAttachment) {
          payload.authenticatorAttachment = credential.authenticatorAttachment;
        }
        return payload;
      }

      async function ensureOk(responsePromise, defaultMessage) {
        const response = await responsePromise;
        if (response.ok) {
          return response;
        }
        const detail = (await response.text()).trim();
        throw new Error(detail ? `${defaultMessage}: ${detail}` : defaultMessage);
      }

      async function fetchChallenge({ token } = {}) {
        const headers = token ? { Authorization: `Bearer ${token}` } : {};
        const response = await ensureOk(
          fetch('/challenge', { method: 'POST', headers }),
          'チャレンジ取得に失敗しました。'
        );
        return readChallengeResponse(response);
      }

      async function registerPasskey({ challenge, credential, token }) {
        const payload = serializeRegistrationCredential(credential);
        await ensureOk(
          fetch(`/passkey?challenge=${encodeURIComponent(challenge)}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              Authorization: `Bearer ${token}`,
            },
            body: JSON.stringify(payload),
          }),
          'Passkey登録に失敗しました。'
        );
      }

      async function requestToken(payload) {
        const response = await ensureOk(
          fetch('/token/passkey', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          }),
          'ログインに失敗しました。'
        );
        return response.json();
      }

      async function createUser() {
        const response = await ensureOk(
          fetch('/user', { method: 'POST' }),
          'ユーザー作成に失敗しました。'
        );
        return response.json();
      }

      async function sendVerificationEmail(email, token) {
        const url = new URL('/email/verify/start', window.location.origin);
        url.searchParams.set('email', email);
        await ensureOk(
          fetch(url, {
            method: 'POST',
            headers: { Authorization: `Bearer ${token}` },
          }),
          '確認メールの送信に失敗しました。'
        );
      }

      async function confirmEmailAddress(email, code, token) {
        const url = new URL('/email/verify', window.location.origin);
        url.searchParams.set('email', email);
        url.searchParams.set('password', code);
        await ensureOk(
          fetch(url, {
            method: 'POST',
            headers: { Authorization: `Bearer ${token}` },
          }),
          'メールアドレスの確認に失敗しました。'
        );
      }

      async function sendEmailLoginChallenge(email) {
        const url = new URL('/token/email/start', window.location.origin);
        url.searchParams.set('email', email);
        const response = await ensureOk(
          fetch(url, { method: 'POST' }),
          'ログインコードの送信に失敗しました。'
        );
        return readChallengeResponse(response);
      }

      async function exchangeEmailCodeForToken({ email, code, challenge }) {
        const payload = { challenge, email, otp: code };
        const response = await ensureOk(
          fetch('/token/email', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          }),
          'メールでのログインに失敗しました。'
        );
        return response.json();
      }

      async function runWithButtonDisabled(button, action) {
        button.disabled = true;
        try {
          await action();
        } finally {
          button.disabled = false;
        }
      }

      async function handleCreateUser() {
        status.set('create', 'ユーザー作成中...');
        status.clear('emailStart', 'emailConfirm', 'passkey', 'login', 'emailLogin', 'logout');
        try {
          const payload = await createUser();
          session.apply(payload);
          session.updateEmail(null);
          emailLoginChallenge = null;
          status.set('create', 'ユーザーを作成しトークンを取得しました。');
        } catch (error) {
          console.error(error);
          status.set('create', error.message || 'ユーザー作成に失敗しました。', { error: true });
        }
      }

      async function handleSendVerificationEmail() {
        const { token } = session.data;
        const email = elements.inputs.email.value.trim();
        if (!token) {
          status.set('emailStart', '先にユーザーを作成またはログインしてください。', { error: true });
          return;
        }
        if (!email) {
          status.set('emailStart', 'メールアドレスを入力してください。', { error: true });
          return;
        }

        status.set('emailStart', '確認メール送信中...');
        status.clear('emailConfirm', 'logout');
        try {
          await sendVerificationEmail(email, token);
          session.updateEmail(email);
          status.set('emailStart', '確認メールを送信しました。');
        } catch (error) {
          console.error(error);
          status.set('emailStart', error.message || '確認メールの送信に失敗しました。', { error: true });
        }
      }

      async function handleConfirmEmail() {
        const { token } = session.data;
        const email = elements.inputs.email.value.trim();
        const code = elements.inputs.code.value.trim();
        if (!token) {
          status.set('emailConfirm', '先にユーザーを作成またはログインしてください。', { error: true });
          return;
        }
        if (!email) {
          status.set('emailConfirm', 'メールアドレスを入力してください。', { error: true });
          return;
        }
        if (!code) {
          status.set('emailConfirm', '確認コードを入力してください。', { error: true });
          return;
        }

        status.set('emailConfirm', '確認コード送信中...');
        status.clear('logout');
        try {
          await confirmEmailAddress(email, code, token);
          session.updateEmail(email);
          elements.inputs.code.value = '';
          status.set('emailConfirm', 'メールアドレスを認証しました。');
        } catch (error) {
          console.error(error);
          status.set('emailConfirm', error.message || 'メールアドレスの確認に失敗しました。', { error: true });
        }
      }

      async function handleStartEmailLogin() {
        const email = elements.inputs.emailLoginEmail.value.trim();
        if (!email) {
          status.set('emailLogin', 'メールアドレスを入力してください。', { error: true });
          return;
        }

        status.set('emailLogin', 'ログインコード送信中...');
        status.clear('logout', 'login');
        try {
          emailLoginChallenge = await sendEmailLoginChallenge(email);
          elements.inputs.emailLoginCode.value = '';
          status.set('emailLogin', '確認コードを送信しました。メールをご確認ください。');
        } catch (error) {
          console.error(error);
          status.set('emailLogin', error.message || 'ログインコードの送信に失敗しました。', { error: true });
        }
      }

      async function handleCompleteEmailLogin() {
        const email = elements.inputs.emailLoginEmail.value.trim();
        const code = elements.inputs.emailLoginCode.value.trim();

        if (!email) {
          status.set('emailLogin', 'メールアドレスを入力してください。', { error: true });
          return;
        }
        if (!code) {
          status.set('emailLogin', '確認コードを入力してください。', { error: true });
          return;
        }
        if (!emailLoginChallenge) {
          status.set('emailLogin', '先にログインコードを送信してください。', { error: true });
          return;
        }

        status.set('emailLogin', 'ログイン処理中...');
        status.clear('logout', 'login');
        try {
          const tokens = await exchangeEmailCodeForToken({
            email,
            code,
            challenge: emailLoginChallenge,
          });
          emailLoginChallenge = null;
          session.apply(tokens);
          session.updateEmail(email);
          elements.inputs.emailLoginCode.value = '';
          status.set('emailLogin', 'メールアドレスでログインしました。');
          status.clear('login');
        } catch (error) {
          console.error(error);
          status.set('emailLogin', error.message || 'メールでのログインに失敗しました。', { error: true });
        }
      }

      async function handleAddPasskey() {
        const { token, userID } = session.data;
        if (!token) {
          status.set('passkey', '先にユーザーを作成またはログインしてください。', { error: true });
          return;
        }
        if (!userID) {
          status.set('passkey', 'ユーザーIDを取得できませんでした。', { error: true });
          return;
        }
        if (!supportsWebAuthn) {
          status.set('passkey', 'このブラウザーは WebAuthn をサポートしていません。', { error: true });
          return;
        }

        status.set('passkey', 'チャレンジ取得中...');
        status.clear('logout');
        try {
          const challenge = await fetchChallenge({ token });
          const options = buildRegistrationOptions(challenge, userID);
          const credential = await navigator.credentials.create({ publicKey: options });
          if (!credential) {
            throw new Error('認証器がキャンセルされました。');
          }

          await registerPasskey({ challenge, credential, token });
          status.set('passkey', 'Passkey を登録しました。');
        } catch (error) {
          console.error(error);
          status.set('passkey', error.message || 'Passkey登録に失敗しました。', { error: true });
        }
      }

      async function handleLogin() {
        if (!supportsWebAuthn) {
          status.set('login', 'このブラウザーは WebAuthn をサポートしていません。', { error: true });
          return;
        }

        status.set('login', 'チャレンジ取得中...');
        status.clear('logout', 'emailLogin');
        try {
          const challenge = await fetchChallenge();
          const options = buildAuthenticationOptions(challenge);
          const credential = await navigator.credentials.get({ publicKey: options });
          if (!credential) {
            throw new Error('認証器がキャンセルされました。');
          }

          const payload = serializeAuthenticationCredential(credential);
          payload.challenge = challenge;

          const tokens = await requestToken(payload);
          session.apply(tokens);
          status.set('login', 'Passkeyでログインしました。新しいトークンを取得しました。');
        } catch (error) {
          console.error(error);
          status.set('login', error.message || 'ログインに失敗しました。', { error: true });
        }
      }

      function handleLogout() {
        session.reset();
        emailLoginChallenge = null;
        status.set('logout', 'ログアウトしました。');
        status.clear('create', 'emailStart', 'emailConfirm', 'passkey', 'login', 'emailLogin');
      }

      const {
        create,
        sendEmail,
        confirmEmail,
        addPasskey,
        login,
        startEmailLogin,
        completeEmailLogin,
        logout,
      } = elements.buttons;
      create.addEventListener('click', () => runWithButtonDisabled(create, handleCreateUser));
      sendEmail.addEventListener('click', () => runWithButtonDisabled(sendEmail, handleSendVerificationEmail));
      confirmEmail.addEventListener('click', () => runWithButtonDisabled(confirmEmail, handleConfirmEmail));
      addPasskey.addEventListener('click', () => runWithButtonDisabled(addPasskey, handleAddPasskey));
      startEmailLogin.addEventListener('click', () => runWithButtonDisabled(startEmailLogin, handleStartEmailLogin));
      completeEmailLogin.addEventListener('click', () => runWithButtonDisabled(completeEmailLogin, handleCompleteEmailLogin));
      login.addEventListener('click', () => runWithButtonDisabled(login, handleLogin));
      logout.addEventListener('click', handleLogout);

      if (!supportsWebAuthn) {
        addPasskey.disabled = true;
        login.disabled = true;
        status.set('passkey', 'このブラウザーは WebAuthn をサポートしていません。', { error: true });
        status.set('login', 'このブラウザーは WebAuthn をサポートしていません。', { error: true });
      }

      session.render();
    })();
  </script>
</body>
</html>
