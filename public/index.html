<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>BlindLog Controls</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root { color-scheme: light dark; }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f8fafc;
      color: #0f172a;
      line-height: 1.5;
    }
    main {
      max-width: 640px;
      margin: 0 auto;
      padding: 2.5rem 1.5rem;
    }
    h1 {
      font-size: 1.8rem;
      margin-bottom: 1.5rem;
    }
    section {
      background: #ffffff;
      border-radius: 16px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.1);
    }
    h2 {
      margin: 0 0 0.75rem;
      font-size: 1.2rem;
    }
    button {
      appearance: none;
      border: none;
      border-radius: 999px;
      padding: 0.6rem 1.4rem;
      background: #2563eb;
      color: #ffffff;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.1s ease;
    }
    button:disabled {
      background: #9ca3af;
      cursor: progress;
    }
    button:not(:disabled):hover {
      background: #1d4ed8;
    }
    button:not(:disabled):active {
      transform: scale(0.97);
    }
    input {
      width: 100%;
      padding: 0.6rem 0.75rem;
      border-radius: 10px;
      border: 1px solid #cbd5f5;
      background: #ffffff;
      font-size: 1rem;
      color: inherit;
    }
    input:focus {
      outline: none;
      border-color: #60a5fa;
      box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.25);
    }
    .field {
      margin-bottom: 0.9rem;
    }
    .field label {
      display: block;
      margin-bottom: 0.35rem;
      font-weight: 600;
      font-size: 0.95rem;
    }
    .status {
      min-height: 1.25rem;
      margin-top: 0.75rem;
      font-size: 0.95rem;
      font-weight: 500;
    }
    pre {
      background: #0f172a;
      color: #e2e8f0;
      border-radius: 12px;
      padding: 1rem;
      overflow-x: auto;
      font-size: 0.9rem;
    }
    @media (prefers-color-scheme: dark) {
      body { background: #0f172a; color: #e2e8f0; }
      section { background: #1f2937; box-shadow: 0 16px 40px rgba(2, 6, 23, 0.45); }
      button { background: #38bdf8; color: #0f172a; }
      button:not(:disabled):hover { background: #0ea5e9; }
      input { background: #111827; border-color: #334155; color: #e2e8f0; }
      input:focus { border-color: #38bdf8; box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.4); }
      pre { background: #020617; color: #cbd5f5; }
    }
  </style>
</head>
<body>
  <main>
    <h1>BlindLog Passkey Playground</h1>

    <section>
      <h2>ユーザー作成</h2>
      <p>匿名ユーザーを作成して認証トークンを取得します。</p>
      <button id="create-user" type="button">ユーザー作成</button>
      <p id="create-status" class="status" role="status"></p>
    </section>

    <section>
      <h2>メールアドレス認証</h2>
      <p>トークンを使って確認メールを送り、受け取ったコードで認証します。</p>
      <div class="field">
        <label for="email-input">メールアドレス</label>
        <input id="email-input" type="email" autocomplete="email" placeholder="user@example.com">
      </div>
      <button id="send-email" type="button">確認メール送信</button>
      <p id="email-start-status" class="status" role="status"></p>
      <div class="field">
        <label for="email-code">確認コード</label>
        <input id="email-code" type="text" inputmode="numeric" autocomplete="one-time-code" placeholder="6桁のコード">
      </div>
      <button id="confirm-email" type="button">コードを送信</button>
      <p id="email-confirm-status" class="status" role="status"></p>
    </section>

    <section>
      <h2>Passkey追加</h2>
      <p>既存のトークンでチャレンジを取得し、Passkey を登録します。</p>
      <button id="add-passkey" type="button">Passkey追加</button>
      <p id="passkey-status" class="status" role="status"></p>
    </section>

    <section>
      <h2>Passkeyログイン</h2>
      <p>Passkey を使って認証し、新しいトークンを取得します。</p>
      <button id="login" type="button">Passkeyでログイン</button>
      <p id="login-status" class="status" role="status"></p>
    </section>

    <section>
      <h2>メールログイン</h2>
      <p>メールアドレスにコードを送り、新しいトークンを取得します。</p>
      <div class="field">
        <label for="email-login-input">メールアドレス</label>
        <input id="email-login-input" type="email" autocomplete="email" placeholder="user@example.com">
      </div>
      <button id="start-email-login" type="button">ログインコード送信</button>
      <div class="field">
        <label for="email-login-code">確認コード</label>
        <input id="email-login-code" type="text" inputmode="numeric" autocomplete="one-time-code" placeholder="6桁のコード">
      </div>
      <button id="complete-email-login" type="button">コードでログイン</button>
      <p id="email-login-status" class="status" role="status"></p>
    </section>

    <section>
      <h2>ログアウト</h2>
      <p>保持しているセッション情報を破棄します。</p>
      <button id="logout" type="button">ログアウト</button>
      <p id="logout-status" class="status" role="status"></p>
    </section>

    <section>
      <h2>セッション情報</h2>
      <pre id="session-output">セッションがありません。</pre>
    </section>
  </main>

  <script>
    (() => {
      const supportsWebAuthn = 'PublicKeyCredential' in window;

      const elements = createElementsMap();
      const status = createStatusManager(elements.statuses);
      const session = createSessionManager(elements.sessionOutput);
      const state = {
        emailLoginChallenge: null,
      };

      const api = createApi();
      const webAuthn = createWebAuthnHelpers();

      const userFlow = createUserFlow({ api, session, status, state });
      const emailVerificationFlow = createEmailVerificationFlow({
        api,
        session,
        status,
        inputs: elements.inputs,
      });
      const emailLoginFlow = createEmailLoginFlow({
        api,
        session,
        status,
        inputs: elements.inputs,
        state,
      });
      const passkeyFlow = createPasskeyFlow({
        api,
        session,
        status,
        webAuthn,
        supportsWebAuthn,
      });
      const logoutFlow = createLogoutFlow({ session, status, state });

      init();

      function init() {
        const {
          create,
          sendEmail,
          confirmEmail,
          addPasskey,
          login,
          startEmailLogin,
          completeEmailLogin,
          logout,
        } = elements.buttons;

        bindAsync(create, userFlow);
        bindAsync(sendEmail, emailVerificationFlow.send);
        bindAsync(confirmEmail, emailVerificationFlow.confirm);
        bindAsync(addPasskey, passkeyFlow.add);
        bindAsync(login, passkeyFlow.login);
        bindAsync(startEmailLogin, emailLoginFlow.start);
        bindAsync(completeEmailLogin, emailLoginFlow.complete);
        logout.addEventListener('click', logoutFlow);

        if (!supportsWebAuthn) {
          addPasskey.disabled = true;
          login.disabled = true;
          status.set('passkey', 'このブラウザーは WebAuthn をサポートしていません。', { error: true });
          status.set('login', 'このブラウザーは WebAuthn をサポートしていません。', { error: true });
        }

        session.render();
      }

      function createUserFlow({ api, session, status, state }) {
        return async function handleCreateUser() {
          status.set('create', 'ユーザー作成中...');
          status.clear('emailStart', 'emailConfirm', 'passkey', 'login', 'emailLogin', 'logout');
          try {
            const payload = await api.createUser();
            session.apply(payload);
            session.updateEmail(null);
            state.emailLoginChallenge = null;
            status.set('create', 'ユーザーを作成しトークンを取得しました。');
          } catch (error) {
            console.error(error);
            status.set('create', error.message || 'ユーザー作成に失敗しました。', { error: true });
          }
        };
      }

      function createEmailVerificationFlow({ api, session, status, inputs }) {
        const emailInput = inputs.email;
        const codeInput = inputs.code;

        return {
          async send() {
            const { token } = session.data;
            const email = emailInput.value.trim();
            if (!token) {
              status.set('emailStart', '先にユーザーを作成またはログインしてください。', { error: true });
              return;
            }
            if (!email) {
              status.set('emailStart', 'メールアドレスを入力してください。', { error: true });
              return;
            }

            status.set('emailStart', '確認メール送信中...');
            status.clear('emailConfirm', 'logout');
            try {
              await api.sendVerificationEmail({ email, token });
              session.updateEmail(email);
              status.set('emailStart', '確認メールを送信しました。');
            } catch (error) {
              console.error(error);
              status.set('emailStart', error.message || '確認メールの送信に失敗しました。', { error: true });
            }
          },

          async confirm() {
            const { token } = session.data;
            const email = emailInput.value.trim();
            const code = codeInput.value.trim();
            if (!token) {
              status.set('emailConfirm', '先にユーザーを作成またはログインしてください。', { error: true });
              return;
            }
            if (!email) {
              status.set('emailConfirm', 'メールアドレスを入力してください。', { error: true });
              return;
            }
            if (!code) {
              status.set('emailConfirm', '確認コードを入力してください。', { error: true });
              return;
            }

            status.set('emailConfirm', '確認コード送信中...');
            status.clear('logout');
            try {
              await api.confirmEmailAddress({ email, code, token });
              session.updateEmail(email);
              codeInput.value = '';
              status.set('emailConfirm', 'メールアドレスを認証しました。');
            } catch (error) {
              console.error(error);
              status.set('emailConfirm', error.message || 'メールアドレスの確認に失敗しました。', { error: true });
            }
          },
        };
      }

      function createEmailLoginFlow({ api, session, status, inputs, state }) {
        const emailInput = inputs.emailLoginEmail;
        const codeInput = inputs.emailLoginCode;

        return {
          async start() {
            const email = emailInput.value.trim();
            if (!email) {
              status.set('emailLogin', 'メールアドレスを入力してください。', { error: true });
              return;
            }

            status.set('emailLogin', 'ログインコード送信中...');
            status.clear('logout', 'login');
            try {
              state.emailLoginChallenge = await api.sendEmailLoginChallenge(email);
              codeInput.value = '';
              status.set('emailLogin', '確認コードを送信しました。メールをご確認ください。');
            } catch (error) {
              console.error(error);
              status.set('emailLogin', error.message || 'ログインコードの送信に失敗しました。', { error: true });
            }
          },

          async complete() {
            const email = emailInput.value.trim();
            const otp = codeInput.value.trim();

            if (!email) {
              status.set('emailLogin', 'メールアドレスを入力してください。', { error: true });
              return;
            }
            if (!otp) {
              status.set('emailLogin', '確認コードを入力してください。', { error: true });
              return;
            }
            if (!state.emailLoginChallenge) {
              status.set('emailLogin', '先にログインコードを送信してください。', { error: true });
              return;
            }

            status.set('emailLogin', 'ログイン処理中...');
            status.clear('logout', 'login');
            try {
              const tokens = await api.exchangeEmailCodeForToken({
                email,
                otp,
                challenge: state.emailLoginChallenge,
              });
              state.emailLoginChallenge = null;
              session.apply(tokens);
              session.updateEmail(email);
              codeInput.value = '';
              status.set('emailLogin', 'メールアドレスでログインしました。');
              status.clear('login');
            } catch (error) {
              console.error(error);
              status.set('emailLogin', error.message || 'メールでのログインに失敗しました。', { error: true });
            }
          },
        };
      }

      function createPasskeyFlow({ api, session, status, webAuthn, supportsWebAuthn }) {
        return {
          async add() {
            const { token, userID } = session.data;
            if (!token) {
              status.set('passkey', '先にユーザーを作成またはログインしてください。', { error: true });
              return;
            }
            if (!userID) {
              status.set('passkey', 'ユーザーIDを取得できませんでした。', { error: true });
              return;
            }
            if (!supportsWebAuthn) {
              status.set('passkey', 'このブラウザーは WebAuthn をサポートしていません。', { error: true });
              return;
            }

            status.set('passkey', 'チャレンジ取得中...');
            status.clear('logout');
            try {
              const challenge = await api.fetchChallenge({ token });
              const options = webAuthn.buildRegistrationOptions(challenge, userID);
              const credential = await navigator.credentials.create({ publicKey: options });
              if (!credential) {
                throw new Error('認証器がキャンセルされました。');
              }

              const payload = webAuthn.serializeRegistrationCredential(credential);
              await api.registerPasskey({ challenge, payload, token });
              status.set('passkey', 'Passkey を登録しました。');
            } catch (error) {
              console.error(error);
              status.set('passkey', error.message || 'Passkey登録に失敗しました。', { error: true });
            }
          },

          async login() {
            if (!supportsWebAuthn) {
              status.set('login', 'このブラウザーは WebAuthn をサポートしていません。', { error: true });
              return;
            }

            status.set('login', 'チャレンジ取得中...');
            status.clear('logout', 'emailLogin');
            try {
              const challenge = await api.fetchChallenge();
              const options = webAuthn.buildAuthenticationOptions(challenge);
              const credential = await navigator.credentials.get({ publicKey: options });
              if (!credential) {
                throw new Error('認証器がキャンセルされました。');
              }

              const payload = webAuthn.serializeAuthenticationCredential(credential, challenge);
              const tokens = await api.requestPasskeyToken(payload);
              session.apply(tokens);
              status.set('login', 'Passkeyでログインしました。新しいトークンを取得しました。');
            } catch (error) {
              console.error(error);
              status.set('login', error.message || 'ログインに失敗しました。', { error: true });
            }
          },
        };
      }

      function createLogoutFlow({ session, status, state }) {
        return function handleLogout() {
          session.reset();
          state.emailLoginChallenge = null;
          status.set('logout', 'ログアウトしました。');
          status.clear('create', 'emailStart', 'emailConfirm', 'passkey', 'login', 'emailLogin');
        };
      }

      function bindAsync(button, action) {
        button.addEventListener('click', () => runWithButtonDisabled(button, action));
      }

      async function runWithButtonDisabled(button, action) {
        button.disabled = true;
        try {
          await action();
        } finally {
          button.disabled = false;
        }
      }

      function createElementsMap() {
        return {
          buttons: {
            create: document.getElementById('create-user'),
            sendEmail: document.getElementById('send-email'),
            confirmEmail: document.getElementById('confirm-email'),
            addPasskey: document.getElementById('add-passkey'),
            login: document.getElementById('login'),
            startEmailLogin: document.getElementById('start-email-login'),
            completeEmailLogin: document.getElementById('complete-email-login'),
            logout: document.getElementById('logout'),
          },
          statuses: {
            create: document.getElementById('create-status'),
            emailStart: document.getElementById('email-start-status'),
            emailConfirm: document.getElementById('email-confirm-status'),
            passkey: document.getElementById('passkey-status'),
            login: document.getElementById('login-status'),
            emailLogin: document.getElementById('email-login-status'),
            logout: document.getElementById('logout-status'),
          },
          inputs: {
            email: document.getElementById('email-input'),
            code: document.getElementById('email-code'),
            emailLoginEmail: document.getElementById('email-login-input'),
            emailLoginCode: document.getElementById('email-login-code'),
          },
          sessionOutput: document.getElementById('session-output'),
        };
      }

      function createStatusManager(statusElements) {
        return {
          set(key, message, { error = false } = {}) {
            const element = statusElements[key];
            if (!element) return;
            element.textContent = message;
            element.style.color = error ? '#dc2626' : '';
          },
          clear(...keys) {
            keys.forEach(key => {
              const element = statusElements[key];
              if (element) {
                element.textContent = '';
                element.style.color = '';
              }
            });
          },
        };
      }

      function createSessionManager(outputElement) {
        const APPLE_REFERENCE_DATE_MS = Date.UTC(2001, 0, 1);
        const data = {
          userID: null,
          token: null,
          tokenExpiresAt: null,
          refreshToken: null,
          refreshTokenExpiresAt: null,
          email: null,
        };

        function render() {
          if (!data.userID) {
            outputElement.textContent = 'セッションがありません。';
            return;
          }
          outputElement.textContent = JSON.stringify(data, null, 2);
        }

        function formatReferenceDate(value) {
          if (typeof value !== 'number' || Number.isNaN(value)) {
            return null;
          }
          return new Date(APPLE_REFERENCE_DATE_MS + value * 1000).toISOString();
        }

        return {
          data,
          apply(payload) {
            const userID = payload?.userID ?? payload?.id ?? null;
            data.userID = userID;
            data.token = payload?.token ?? null;
            data.tokenExpiresAt = formatReferenceDate(payload?.tokenExpiredDate);
            data.refreshToken = payload?.refreshToken ?? null;
            data.refreshTokenExpiresAt = formatReferenceDate(payload?.refreshTokenExpiredDate);
            render();
          },
          updateEmail(email) {
            data.email = email ? email.trim() : null;
            render();
          },
          reset() {
            data.userID = null;
            data.token = null;
            data.tokenExpiresAt = null;
            data.refreshToken = null;
            data.refreshTokenExpiresAt = null;
            data.email = null;
            render();
          },
          render,
        };
      }

      function createApi() {
        return {
          async createUser() {
            const response = await post('/user', { message: 'ユーザー作成に失敗しました。' });
            return response.json();
          },

          async sendVerificationEmail({ email, token }) {
            const url = new URL('/email/verify/start', window.location.origin);
            url.searchParams.set('email', email);
            await post(url, {
              headers: { Authorization: `Bearer ${token}` },
              message: '確認メールの送信に失敗しました。',
            });
          },

          async confirmEmailAddress({ email, code, token }) {
            const url = new URL('/email/verify', window.location.origin);
            url.searchParams.set('email', email);
            url.searchParams.set('password', code);
            await post(url, {
              headers: { Authorization: `Bearer ${token}` },
              message: 'メールアドレスの確認に失敗しました。',
            });
          },

          async fetchChallenge({ token } = {}) {
            const headers = token ? { Authorization: `Bearer ${token}` } : {};
            const response = await post('/challenge', {
              headers,
              message: 'チャレンジ取得に失敗しました。',
            });
            return readChallengeResponse(response);
          },

          async registerPasskey({ challenge, payload, token }) {
            await post(`/passkey?challenge=${encodeURIComponent(challenge)}`, {
              headers: {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${token}`,
              },
              body: JSON.stringify(payload),
              message: 'Passkey登録に失敗しました。',
            });
          },

          async requestPasskeyToken(payload) {
            return postJSON('/token/passkey', payload, {
              message: 'ログインに失敗しました。',
            });
          },

          async sendEmailLoginChallenge(email) {
            const url = new URL('/token/email/start', window.location.origin);
            url.searchParams.set('email', email);
            const response = await post(url, {
              message: 'ログインコードの送信に失敗しました。',
            });
            return readChallengeResponse(response);
          },

          async exchangeEmailCodeForToken(payload) {
            return postJSON('/token/email', payload, {
              message: 'メールでのログインに失敗しました。',
            });
          },
        };
      }

      function createWebAuthnHelpers() {
        const encoder = new TextEncoder();
        return {
          buildRegistrationOptions(challenge, userID) {
            return {
              challenge: base64ToUint8Array(challenge),
              rp: { name: document.title || 'BlindLog', id: window.location.hostname },
              user: {
                id: encoder.encode(userID),
                name: userID,
                displayName: userID,
              },
              pubKeyCredParams: [
                { type: 'public-key', alg: -7 },
                { type: 'public-key', alg: -257 },
              ],
              authenticatorSelection: { userVerification: 'preferred' },
              timeout: 60000,
              attestation: 'none',
            };
          },

          buildAuthenticationOptions(challenge) {
            return {
              challenge: base64ToUint8Array(challenge),
              rpId: window.location.hostname,
              timeout: 60000,
              userVerification: 'preferred',
            };
          },

          serializeRegistrationCredential(credential) {
            const { response } = credential;
            return {
              id: credential.id,
              rawId: arrayBufferToBase64Url(credential.rawId),
              type: credential.type,
              response: {
                clientDataJSON: arrayBufferToBase64Url(response.clientDataJSON),
                attestationObject: arrayBufferToBase64Url(response.attestationObject),
              },
            };
          },

          serializeAuthenticationCredential(credential, challenge) {
            const { response } = credential;
            const payload = {
              id: credential.id,
              rawId: arrayBufferToBase64Url(credential.rawId),
              type: credential.type,
              response: {
                clientDataJSON: arrayBufferToBase64Url(response.clientDataJSON),
                authenticatorData: arrayBufferToBase64Url(response.authenticatorData),
                signature: arrayBufferToBase64Url(response.signature),
              },
              challenge,
            };
            if (response.userHandle) {
              payload.response.userHandle = arrayBufferToBase64Url(response.userHandle);
            }
            if (credential.authenticatorAttachment) {
              payload.authenticatorAttachment = credential.authenticatorAttachment;
            }
            return payload;
          },
        };
      }

      function normalizeBase64(input) {
        const base = input.replace(/-/g, '+').replace(/_/g, '/').replace(/\s+/g, '');
        const mod = base.length % 4;
        if (mod === 2) return base + '==';
        if (mod === 3) return base + '=';
        if (mod === 1) return base + '===';
        return base;
      }

      function base64ToUint8Array(base64) {
        const normalized = normalizeBase64(base64);
        const binary = atob(normalized);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i += 1) {
          bytes[i] = binary.charCodeAt(i);
        }
        return bytes;
      }

      function arrayBufferToBase64Url(buffer) {
        const bytes = new Uint8Array(buffer);
        let binary = '';
        for (let i = 0; i < bytes.length; i += 1) {
          binary += String.fromCharCode(bytes[i]);
        }
        const base64 = btoa(binary);
        return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
      }

      async function post(resource, { headers = {}, body, message }) {
        const init = {
          method: 'POST',
          headers,
        };
        if (body !== undefined) {
          init.body = body;
        }
        return ensureOk(fetch(resource, init), message);
      }

      async function postJSON(resource, payload, { headers = {}, message }) {
        const response = await post(resource, {
          headers: {
            'Content-Type': 'application/json',
            ...headers,
          },
          body: JSON.stringify(payload),
          message,
        });
        return response.json();
      }

      async function ensureOk(responsePromise, defaultMessage) {
        const response = await responsePromise;
        if (response.ok) {
          return response;
        }
        const detail = (await response.text()).trim();
        throw new Error(detail ? `${defaultMessage}: ${detail}` : defaultMessage);
      }

      async function readChallengeResponse(response) {
        const text = (await response.text()).trim();
        try {
          const parsed = JSON.parse(text);
          if (typeof parsed === 'string') return parsed;
          if (typeof parsed?.challenge === 'string') return parsed.challenge;
          if (typeof parsed?.value === 'string') return parsed.value;
          if (Array.isArray(parsed?.data)) {
            return arrayBufferToBase64Url(Uint8Array.from(parsed.data).buffer);
          }
        } catch {
          const unquoted = text.replace(/^"|"$/g, '');
          if (unquoted) return unquoted;
        }
        throw new Error('Unexpected challenge response format.');
      }
    })();
  </script>
</body>
</html>
